%!TEX encoding = UTF-8 Unicode
%!TEX root = ../main.tex

\chapter*{What is requirements engineering?}

\textit{Requirements engineering: working with requirements in context.}

\vspace{1em}

\noindent Requirements engineering (RE) is the process focused on the \textit{requirements} of software-intensive systems under development and their \textit{context}, which includes users as well as other surrounding systems. 
The requirements engineering process involves activities such as eliciting, specifying, validating, and selecting requirements. 
Requirements engineering is both a research discipline and an engineering practice, forming the foundation for our human ability to create useful software with high quality in service of mankind. Whenever you work on things involved in the decision-making process of software development you are doing requirements engineering.  

The word ''requirement'' is, within software engineering (SE), often used in a very general sense, standing for \textbf{something needed or wanted}. It is typically used as an abstract term denoting \textit{any} type of information relevant to the intentions behind system development. But not always. The term ''requirement'' is a bit tricky as it is overloaded with several meanings. Sometimes it means that it is an optional wish and sometimes it refers to something already decided and committed for delivery. Sometimes we mean the underlying need or want of a user, but maybe still elusive, while we also may mean the documented \textit{representation} of that underlying need or want. This documented representation may very well differ from the underlying actual need, due to imperfections of our representation. Requirements come in different kinds and shapes at different abstraction levels. Hence, it is wise to be more clear and specific about what kind of requirement we mean, to avoid that our usage of the term is misinterpreted. 

This chapter aims to provide a set of terms that you can use when you think and communicate about requirements. This terminology is the starting-point for learning more about requirements engineering and developing skills needed to contribute to the invention of tomorrows' software.

\section*{Activities in Requirements Engineering}

Working with requirements involves many different tasks and skills. The RE process is often characterized by these interdependent activities: 

\begin{itemize}
  \item \textbf{Elicitation}: to learn, discover \& invent. Requirements needs to be identified before the can play a role in software engineering. But this is often not trivial. We need to work hard to discover the future needs of our users and sometimes we need to be very creative and invent the requirements that represent new ideas for future software technology. Requirements elicitation is a learning and innovation process that provides the knowledge needed by other RE and SE activities.
  \item \textbf{Specification}: to represent, communicate and make persistent. It is not enough to just keep our knowledge about the evolving requirements in our heads. Requirements needs to be represented in a persistent way to that we can communicate over time and space while they evolve. The requirements models that are the results of the requirements specification process should be useful to all humans involved in all dependent software engineering processes through the whole product life-cycle.
  \item \textbf{Validation}: to check that we have modelled the right requirements in a good way. Adequate quality ''good enough'' 
  \item \textbf{Selection}: Prioritize decide plan
\end{itemize}

\section*{Different aspects of requirements}

\subsection*{Functionality aspects}
Functional requirements deals with the expected logical behaviour and the related data needed.
\begin{itemize}
  \item \textbf{data}: what data is stored, domain data model, input, output.
  \item \textbf{logic}: expected behaviour, the functional relation between input and output
\end{itemize}

\subsection*{Quality aspects}
\begin{itemize}
  \item \textbf{accuracy}:
  \item \textbf{capacity}:
\end{itemize}

\subsection*{Levels of abstraction}
The Goal-Design scale
\subsection*{Levels of details}

\subsection*{Levels of aggregation}

\subsection*{Levels of formality}



\section*{Requirements Engineering in relation to other disciplines}

\begin{itemize}
  \item \textbf{Software Engineering}
  \item \textbf{Product Management}
  \item \textbf{Project Management}
  \item \textbf{Agile Development}
  \item \textbf{Open Source Software}
  \item \textbf{Software Testing}
  \item \textbf{Configuration Management}
  \item \textbf{Continuous Integration \& Continuous Delivery}
\end{itemize}

----- 

\section{What is a Requirement?}

\begin{itemize}
  \item Different kinds of requirements
  \item Requriements at different levels
  \item Goal-design-scale
  \item The Feature as a decision unit
  \item Requirements as ideas, decisions, system properties, ...
  \item Quality vs function
\end{itemize}

\section{Activities in Requirements Engineering}

\begin{itemize}
  \item Invent: Elicitation
  \item Persist: Specification
  \item Check: Validation
  \item Decide: Prioritize
  \item Plan: Management
\end{itemize}

\subsection{Requirements Engineering in different project types}

\begin{itemize}
  \item Procurement, private versus public procurement, tender processes
  \item Product development for a market
  \item Bespoke development for a single customer
  \item In-house development for our own use
  \item Community development and open source
\end{itemize}

\subsection{Requirements in the Software Development Process}

\begin{itemize}
  \item Evolution: from inception to migration in the software development lifecycle
  \item Decision-making and change control
  \item Configuration management, git
  \item Increments, commits and releases
  \item Software hosting and issues as requriements
  \item RE and Testing
  \item RE and System Architecture
  \item RE and SW Design, UX, HCI, Usability...
  \item RE and Project Management
  \begin{itemize}
    \item states of requriements (-> Release Planning)
    \item funnel from ideas to implementation
  \end{itemize}
   \item RE and System Operation (Devops, feedback loops, continuous deployment etc)
   \item RE as a communication process, Communication distances
\end{itemize}

\subsection{Requirements in Systems Engineering}

\begin{itemize}
  \item Human-centric systems: Desktop apps, Webb apps
  \item Embedded systems
  \begin{itemize}
    \item Hardware and Software Co-design
    \item Internet of things
  \end{itemize}
  \item Safety-critical systems
\end{itemize}

\section{Ethics in Requirements Engineering}

\begin{itemize}
  \item Systems that are friendly to users and their planet
  \item Systems that spy on humans
  \item Systems that may kill humans
  \item Engineering ethics frameworks
\end{itemize}
